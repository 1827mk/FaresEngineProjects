// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package com.nbu.fares.web;

import com.nbu.fares.domain.ApplicationConstant;
import com.nbu.fares.domain.Location;
import flexjson.JSONSerializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.ui.Model;
import org.springframework.util.FileCopyUtils;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.util.UriComponentsBuilder;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.List;

privileged aspect LocationController_Custom_Controller_Json {
    static Logger logger = LoggerFactory.getLogger(LocationController_Custom_Controller_Json.class);

    @RequestMapping(value = "/findAllCustom", method = RequestMethod.GET, headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> LocationController.findAllCustom() {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        List<Location> locationList = Location.findAllLocations();
        return new ResponseEntity<String>((new JSONSerializer()
                .include("id")
                .include("version")
                .include("locationCode")
                .include("locationName")
                .include("fileName")
//                .include("fileSize")
//                .include("fileData")
                .exclude("*").deepSerialize(locationList)), headers, HttpStatus.OK);
    }

    @RequestMapping(value = "/findLocationCode", method = RequestMethod.GET, headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String>LocationController.findLocationCode(@RequestParam(value="locationCode", required = false)String locationCode,
                                                                     @RequestParam(value="locationName", required = false)String locationName) {
        List<Location> parameterDetail=Location.findLocationByCode(locationCode,locationName);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        if (parameterDetail == null) {
            return new ResponseEntity<String>(headers, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<String>((new JSONSerializer().exclude("*.class")
                .include("id")
                .include("version")
                .include("locationCode")
                .include("locationName")
                .exclude("*")
                .deepSerialize(parameterDetail)),headers, HttpStatus.OK);
    }

    @RequestMapping(value = "/findLocationsByCode", method = RequestMethod.GET, headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String>LocationController.findLocationsByCode(@RequestParam(value="locationCode", required = false)String locationCode) {
        List<Location> parameterDetail=Location.findLocationsByCode(locationCode);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        if (parameterDetail == null) {
            return new ResponseEntity<String>(headers, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<String>((new JSONSerializer().exclude("*.class")
                .include("id")
                .include("version")
                .include("locationCode")
                .include("locationName")
                .exclude("*")
                .deepSerialize(parameterDetail)),headers, HttpStatus.OK);
    }

    @RequestMapping(value = "/findLocationCodeDuplicate", method = RequestMethod.GET, headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String>LocationController.findLocationCodeDuplicate(@RequestParam(value="locationCode", required = false)String locationCode) {
        List<Location> parameterDetail=Location.findLocationCodeDuplicate(locationCode);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        if (parameterDetail == null) {
            return new ResponseEntity<String>(headers, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<String>((new JSONSerializer().exclude("*.class")
                .include("id")
                .include("version")
                .include("locationCode")
                .include("locationName")
                .exclude("*")
                .deepSerialize(parameterDetail)),headers, HttpStatus.OK);
    }
    @RequestMapping(value = "/findLocationNameDuplicate", method = RequestMethod.GET, headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String>LocationController.findLocationNameDuplicate(@RequestParam(value="locationName", required = false)String locationName) {
        List<Location> parameterDetail=Location.findLocationNameDuplicate(locationName);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        if (parameterDetail == null) {
            return new ResponseEntity<String>(headers, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<String>((new JSONSerializer().exclude("*.class")
                .include("id")
                .include("version")
                .include("locationCode")
                .include("locationName")
                .exclude("*")
                .deepSerialize(parameterDetail)),headers, HttpStatus.OK);
    }

    @RequestMapping(value = "/insertLocation", method = RequestMethod.POST, headers = "Accept=application/json")
    public ResponseEntity<String> LocationController.insertLocation(MultipartHttpServletRequest multipartHttpServletRequest) throws IOException {
        ResponseEntity<String> status = null;
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        try {
            MultipartFile multipathFile = multipartHttpServletRequest.getFile("file");
            String json = multipartHttpServletRequest.getParameter("json");
            Location location = Location.fromJsonToLocation(json);
            List<Location> locationList = Location.createLocation(location.getLocationCode(), location.getLocationName());
            if (locationList.size() == 0) {
                byte[] bytes = multipathFile.getBytes();
                File path = new File(ApplicationConstant.PATH_FILE + multipathFile.getOriginalFilename());
                FileCopyUtils.copy(bytes, new FileOutputStream(path));
                location.persist();
                return status = new ResponseEntity<String>(headers, HttpStatus.CREATED);
            } else {
                return status = new ResponseEntity<String>(headers, HttpStatus.CONFLICT);
            }
        } catch (Exception e) {
            logger.error("create:{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/updateLocation", method = RequestMethod.POST, headers = "Accept=application/json")
    public ResponseEntity<String> LocationController.updateLocation(MultipartHttpServletRequest multipartdata) throws IOException {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");
        try {
            MultipartFile multipathFile = multipartdata.getFile("fileedit");
            String json = multipartdata.getParameter("jsonedit");
            Location location = Location.fromJsonToLocation(json);

                byte[] bytes = multipathFile.getBytes();
                File path = new File(ApplicationConstant.PATH_FILE + multipathFile.getOriginalFilename());
                FileCopyUtils.copy(bytes, new FileOutputStream(path));

                Location locationOld = Location.findLocation(location.getId());
                locationOld.setLocationCode(location.getLocationCode());
                locationOld.setLocationName(location.getLocationName());
                locationOld.setFileName(location.getFileName());
                locationOld.merge();
                return new ResponseEntity<String>(headers, HttpStatus.OK);

        } catch (Exception e) {
            logger.error("update:{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    @RequestMapping(value = "/updateLocationNoImage", method = RequestMethod.GET, headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> LocationController.updateLocationNoImage(@RequestParam(value="locationId", required = false)Long locationId,
                                                                        @RequestParam(value="locationCode", required = false)String locationCode,
                                                                        @RequestParam(value="locationName", required = false)String locationName,
                                                                        @RequestParam(value="fileName", required = false)String fileName) {

        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json; charset=utf-8");

        Location locationUpdate = Location.findLocation(locationId);
        if(locationUpdate != null){
            locationUpdate.setLocationCode(locationCode);
            locationUpdate.setLocationName(locationName);
            locationUpdate.setFileName(fileName);
            locationUpdate.merge();
            return new ResponseEntity<String>((new JSONSerializer().deepSerialize("success")),headers, HttpStatus.OK);
        }else{

            return new ResponseEntity<String>((new JSONSerializer().deepSerialize("failed")),headers, HttpStatus.NO_CONTENT);
        }
    }

}
